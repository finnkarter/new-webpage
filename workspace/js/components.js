/**
 * MILBASE Components
 * Ïû¨ÏÇ¨Ïö© Í∞ÄÎä•Ìïú UI Ïª¥Ìè¨ÎÑåÌä∏Îì§
 */

// === Toast ÏïåÎ¶º ÏãúÏä§ÌÖú ===
class Toast {
    constructor() {
        this.container = Utils.$('#toastContainer');
        this.toasts = [];
    }
    
    show(message, type = 'info', duration = 5000) {
        const toast = this.create(message, type);
        this.container.appendChild(toast);
        this.toasts.push(toast);
        
        // Ïï†ÎãàÎ©îÏù¥ÏÖò Ìä∏Î¶¨Í±∞
        requestAnimationFrame(() => {
            Utils.slideUp(toast);
        });
        
        // ÏûêÎèô Ï†úÍ±∞
        if (duration > 0) {
            setTimeout(() => {
                this.remove(toast);
            }, duration);
        }
        
        return toast;
    }
    
    create(message, type) {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        
        const icons = {
            info: '‚ÑπÔ∏è',
            success: '‚úÖ',
            warning: '‚ö†Ô∏è',
            error: '‚ùå'
        };
        
        const titles = {
            info: 'ÏïåÎ¶º',
            success: 'ÏÑ±Í≥µ',
            warning: 'Ï£ºÏùò',
            error: 'Ïò§Î•ò'
        };
        
        toast.innerHTML = `
            <div class="toast-icon">${icons[type] || icons.info}</div>
            <div class="toast-content">
                <div class="toast-title">${titles[type] || titles.info}</div>
                <div class="toast-message">${message}</div>
            </div>
            <button class="toast-close" type="button">√ó</button>
        `;
        
        // Îã´Í∏∞ Î≤ÑÌäº Ïù¥Î≤§Ìä∏
        const closeBtn = toast.querySelector('.toast-close');
        Utils.on(closeBtn, 'click', () => this.remove(toast));
        
        return toast;
    }
    
    remove(toast) {
        if (!toast.parentNode) return;
        
        Utils.addClass(toast, 'removing');
        
        setTimeout(() => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
            
            const index = this.toasts.indexOf(toast);
            if (index > -1) {
                this.toasts.splice(index, 1);
            }
        }, 300);
    }
    
    clear() {
        this.toasts.forEach(toast => this.remove(toast));
    }
}

// === ÏÇ¨Ïù¥Îìú Î©îÎâ¥ Ïª¥Ìè¨ÎÑåÌä∏ ===
class SideMenu {
    constructor() {
        this.menu = Utils.$('#sideMenu');
        this.overlay = Utils.$('#overlay');
        this.toggleBtn = Utils.$('#menuToggle');
        this.closeBtn = Utils.$('#menuClose');
        this.hamburger = this.toggleBtn?.querySelector('.hamburger');
        this.isOpen = false;
        
        this.init();
    }
    
    init() {
        if (this.toggleBtn) {
            Utils.on(this.toggleBtn, 'click', () => this.toggle());
        }
        
        if (this.closeBtn) {
            Utils.on(this.closeBtn, 'click', () => this.close());
        }
        
        if (this.overlay) {
            Utils.on(this.overlay, 'click', () => this.close());
        }
        
        // ESC ÌÇ§Î°ú Îã´Í∏∞
        Utils.on(document, 'keydown', (e) => {
            if (e.key === 'Escape' && this.isOpen) {
                this.close();
            }
        });
    }
    
    open() {
        if (this.isOpen) return;
        
        this.isOpen = true;
        Utils.addClass(this.menu, 'active');
        Utils.addClass(this.overlay, 'active');
        Utils.addClass(this.hamburger, 'active');
        
        // Ìè¨Ïª§Ïä§ Ìä∏Îû©
        this.trapFocus();
        
        // body Ïä§ÌÅ¨Î°§ Î∞©ÏßÄ
        document.body.style.overflow = 'hidden';
    }
    
    close() {
        if (!this.isOpen) return;
        
        this.isOpen = false;
        Utils.removeClass(this.menu, 'active');
        Utils.removeClass(this.overlay, 'active');
        Utils.removeClass(this.hamburger, 'active');
        
        // body Ïä§ÌÅ¨Î°§ Î≥µÏõê
        document.body.style.overflow = '';
        
        // Ìè¨Ïª§Ïä§ Î≥µÏõê
        if (this.toggleBtn) {
            this.toggleBtn.focus();
        }
    }
    
    toggle() {
        if (this.isOpen) {
            this.close();
        } else {
            this.open();
        }
    }
    
    trapFocus() {
        const focusableElements = this.menu.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );
        
        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];
        
        Utils.on(this.menu, 'keydown', (e) => {
            if (e.key !== 'Tab') return;
            
            if (e.shiftKey) {
                if (document.activeElement === firstElement) {
                    e.preventDefault();
                    lastElement.focus();
                }
            } else {
                if (document.activeElement === lastElement) {
                    e.preventDefault();
                    firstElement.focus();
                }
            }
        });
        
        // Ï≤´ Î≤àÏß∏ ÏöîÏÜåÏóê Ìè¨Ïª§Ïä§
        if (firstElement) {
            firstElement.focus();
        }
    }
}

// === ÌÖåÎßà ÌÜ†Í∏Ä Ïª¥Ìè¨ÎÑåÌä∏ ===
class ThemeToggle {
    constructor() {
        this.toggleBtn = Utils.$('#themeToggle');
        this.currentTheme = Utils.storage.get('theme', 'dark');
        
        this.init();
    }
    
    init() {
        this.applyTheme(this.currentTheme);
        
        if (this.toggleBtn) {
            Utils.on(this.toggleBtn, 'click', () => this.toggle());
        }
    }
    
    toggle() {
        const newTheme = this.currentTheme === 'dark' ? 'light' : 'dark';
        this.setTheme(newTheme);
    }
    
    setTheme(theme) {
        this.currentTheme = theme;
        this.applyTheme(theme);
        Utils.storage.set('theme', theme);
    }
    
    applyTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        
        if (this.toggleBtn) {
            const icon = this.toggleBtn.querySelector('.icon');
            if (icon) {
                icon.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
            }
        }
    }
}

// === Ïã§ÏãúÍ∞Ñ ÏãúÍ≥Ñ Ïª¥Ìè¨ÎÑåÌä∏ ===
class Clock {
    constructor() {
        this.element = Utils.$('#currentTime');
        this.interval = null;
        
        this.init();
    }
    
    init() {
        if (!this.element) return;
        
        this.update();
        this.interval = setInterval(() => this.update(), 1000);
    }
    
    update() {
        const now = new Date();
        const timeString = Utils.formatTime(now);
        const dateString = Utils.formatDate(now);
        
        this.element.textContent = `${dateString} ${timeString}`;
    }
    
    destroy() {
        if (this.interval) {
            clearInterval(this.interval);
            this.interval = null;
        }
    }
}

// === ÏßÑÌñâÎ•† Î∞î Ïª¥Ìè¨ÎÑåÌä∏ ===
class ProgressBar {
    constructor(element) {
        this.element = typeof element === 'string' ? Utils.$(element) : element;
        this.fill = this.element?.querySelector('.progress-fill');
        this.currentValue = 0;
    }
    
    setValue(value, animate = true) {
        value = Utils.clamp(value, 0, 100);
        this.currentValue = value;
        
        if (!this.fill) return;
        
        if (animate) {
            // Î∂ÄÎìúÎü¨Ïö¥ Ïï†ÎãàÎ©îÏù¥ÏÖò
            this.fill.style.transition = 'width 1s ease-out';
        } else {
            this.fill.style.transition = 'none';
        }
        
        this.fill.style.width = `${value}%`;
    }
    
    getValue() {
        return this.currentValue;
    }
}

// === Î≤ÑÌäº Î¶¨Ìîå Ìö®Í≥º Ïª¥Ìè¨ÎÑåÌä∏ ===
class RippleEffect {
    static init() {
        // Î™®Îì† Î≤ÑÌäºÏóê Î¶¨Ìîå Ìö®Í≥º Ï∂îÍ∞Ä
        Utils.on(document, 'click', (e) => {
            const button = e.target.closest('.action-btn, .btn-icon');
            if (button) {
                RippleEffect.create(button, e);
            }
        });
    }
    
    static create(element, event) {
        const rect = element.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        const x = event.clientX - rect.left - size / 2;
        const y = event.clientY - rect.top - size / 2;
        
        const ripple = document.createElement('div');
        ripple.style.cssText = `
            position: absolute;
            width: ${size}px;
            height: ${size}px;
            left: ${x}px;
            top: ${y}px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: scale(0);
            animation: ripple 0.6s ease-out;
            pointer-events: none;
        `;
        
        element.style.position = 'relative';
        element.style.overflow = 'hidden';
        element.appendChild(ripple);
        
        setTimeout(() => {
            if (ripple.parentNode) {
                ripple.parentNode.removeChild(ripple);
            }
        }, 600);
    }
}

// === ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§ Í¥ÄÎ¶¨Ïûê ===
class KeyboardShortcuts {
    constructor() {
        this.shortcuts = new Map();
        this.init();
    }
    
    init() {
        Utils.on(document, 'keydown', (e) => this.handleKeydown(e));
        
        // Í∏∞Î≥∏ Îã®Ï∂ïÌÇ§ Îì±Î°ù
        this.register('Escape', () => {
            // ÏÇ¨Ïù¥Îìú Î©îÎâ¥ÎÇò Î™®Îã¨ Îã´Í∏∞
            if (window.sideMenu?.isOpen) {
                window.sideMenu.close();
            }
        });
        
        this.register('KeyM', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                window.sideMenu?.toggle();
            }
        });
    }
    
    register(key, callback, options = {}) {
        this.shortcuts.set(key, { callback, options });
    }
    
    unregister(key) {
        this.shortcuts.delete(key);
    }
    
    handleKeydown(e) {
        const shortcut = this.shortcuts.get(e.code || e.key);
        if (shortcut) {
            const { callback, options } = shortcut;
            
            // ÏàòÏ†ïÌÇ§ ÌôïÏù∏
            if (options.ctrl && !e.ctrlKey) return;
            if (options.shift && !e.shiftKey) return;
            if (options.alt && !e.altKey) return;
            if (options.meta && !e.metaKey) return;
            
            callback(e);
        }
    }
}

// === Ï†ÑÏó≠ Ïª¥Ìè¨ÎÑåÌä∏ Ï¥àÍ∏∞Ìôî ===
let toast, sideMenu, themeToggle, clock, keyboardShortcuts;

const initComponents = () => {
    // Ïª¥Ìè¨ÎÑåÌä∏ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
    toast = new Toast();
    sideMenu = new SideMenu();
    themeToggle = new ThemeToggle();
    clock = new Clock();
    keyboardShortcuts = new KeyboardShortcuts();
    
    // Î¶¨Ìîå Ìö®Í≥º Ï¥àÍ∏∞Ìôî
    RippleEffect.init();
    
    // Ï†ÑÏó≠ Í∞ùÏ≤¥Î°ú ÎÖ∏Ï∂ú
    window.toast = toast;
    window.sideMenu = sideMenu;
    window.themeToggle = themeToggle;
    window.clock = clock;
    window.keyboardShortcuts = keyboardShortcuts;
    window.ProgressBar = ProgressBar;
    
    console.log('üéñÔ∏è MILBASE Components initialized');
};

// DOM Î°úÎìú ÏôÑÎ£å Ïãú Ï¥àÍ∏∞Ìôî
if (document.readyState === 'loading') {
    Utils.on(document, 'DOMContentLoaded', initComponents);
} else {
    initComponents();
}